function [sampleStructOut, mixedFrac] = gpSamplerPercentile(sampleStruct, nPoints, bias, maxTime, maxSteps, threads, nPointsCheck,previousSampling)
if ~exist('previousSampling','var') || isempty(previousSampling)
    previousSampling = [];
end
%%%%%%%%%%%%%%%%%%%% Modified by Fernando Silva-Lance 2021 %%%%%%%%%%%%%%%
%Modification1: Creates warmup points with a varying feasibility tolerance if the model is too
%constraint. 
%Modification 2: Does the sampling according to the following data recoved
%from a previous sampling, using the dynamic percentile: 
        %Distance between furthest and central solution
        %Number of valid solutions
    %The sampling goes as the normal gpsampler algorithm would do, it stops
    %when there is an equal or bigger number of sampled points to those
    %specified by the previous dynamic percentile. The sampled points must have
    %a lower or equal euclidean distance value, with respect to a central
    %point, compared to the Distance between furthest and central solution
    %of the dynamic percentile
%If you want to go to the modified sections of code just look for the following
%comment "MODIFICATION"

% Samples an arbitrary linearly constrained space using a fixed
% number of points that are moved in parallel
% The space is defined by
%
% .. math::
%    A x \leq, =, \geq b \\
%    lb \leq x \leq ub
%
% USAGE:
%
%    [sampleStructOut, mixedFraction] = gpSampler(sampleStruct, nPoints, bias, maxTime, maxSteps, threads, nPointsCheck)
%
% INPUTS:
%    sampleStruct:      Structure describing the space to be sampled and
%                       previous point sets:
%
%                         * A - LHS matrix (optionally, if not A script checks for S)
%                         * b - RHS vector
%                         * lb - Lower bound
%                         * ub - Upper bound
%                         * csense - Constraint type for each row in `A` ('G', 'L', 'E')
%                         * warmupPoints - Set of warmup points (optional, generated by default)
%                         * points - Currently sampled points (optional)
%
% OPTIONAL INPUTS:
%    nPoints:           Number of points used in sampling
%                       (default = `2 * nRxns` or 5000 whichever is greater)
%    bias:              Structure with fields:
%
%                         * method - Biasing distribution: 'uniform', 'normal'
%                         * index - The reaction indexes which to bias (`nBias` total)
%                         * param - `nBias x 2` matrix of parameters (for uniform it's min max, for normal it's `mu`, `sigma`).
%    maxTime:           Maximum time alloted for the sampling in seconds
%                       (default 600 s, pass an empty number [] to set `maxSteps` instead)
%    maxSteps:          Maximum number of steps to take (default 1e10). Sampler
%                       will run until either maxStep or maxTime is reached.
%                       Set maxStep or maxTime to 0 and no sampling will occur
%                       (only warmup points generated).
%    threads:           number of threads the sampler will use.  If you have a
%                       dual core machine, you can set it to 2 etc.  The speed
%                       up is almost linear w/ the number of cores.
%                       If using this feature and 2009a or newer, a futher
%                       speedup can be obtained by starting matlab from the
%                       command line by "typing matlab -singleCompThread"
%                       New feature:  if `threads` < 0, use distributed toolbox.
%    nPointsCheck:      Checks that minimum number of points (`2 * nRxns`) are
%                       used. (Default = true).
%
% OUTPUTS:
%    sampleStructOut:   The sampling structure with some extra fields.
%    mixedFract:        The fraction mixed (relative to the `warmupPts`).  A value of 1
%                       means not mixed at all.  A value of .5 means completely mixed.

sampleStructOut = 0; % in case of returning early
mixedFrac = 1; % in case of returning early
% Parameter Processing / error checking
if nargin < 2
    nPoints = 5000;
end
if nargin < 3
    bias = [];
end
if ~isempty(bias)
    if ~isfield (bias, 'method')
        display('bias does not have a method set');
        return;
    end
end
if nargin < 4 || (isempty(maxTime) && isempty(maxSteps))
    maxTime = 10*60; % 10 minutes
end
if (nargin < 5) || isempty(maxSteps)
    % Max time takes precedence
    maxSteps = 1e10;
else
    % Set max steps instead of max time
    if (isempty(maxTime))
        maxTime = 1e10;
    end
end

if nargin < 6 || isempty(threads)
    threads = 1;
end

if nargin < 7, nPointsCheck = true; end

% Sanity checking
if (~ isfield (sampleStruct, 'A'))
    if isfield(sampleStruct, 'S')
        display('A set to S');
        sampleStruct.A = sampleStruct.S;
    else
        display('A and/or S not set');
        return;
    end
end
if (~ isfield (sampleStruct, 'b'))
    sampleStruct.b = zeros(size(sampleStruct.A,1), 1);
    display('Warning:  b not set.  Defaulting to zeros');
end
if (~ isfield (sampleStruct, 'csense'))
    sampleStruct.csense(1:size(sampleStruct.A,1)) = 'E';
    display('Warning:  csense not set.  Defaulting to all Equality constraints');
end
if (~isfield (sampleStruct, 'lb'))
    display('lb not set');
    return;
end
if (~isfield (sampleStruct, 'ub'))
    display('ub not set');
    return;
end

%% internal data generation
% make internal structure
[A, b, csense, lb, ub] = deal(sampleStruct.A, sampleStruct.b, sampleStruct.csense, sampleStruct.lb, sampleStruct.ub);

% constInd = (lb == ub);
% constVal = lb(constInd);
% Aconst = A(:,constInd);
% b = b - Aconst*constVal;
% A = A(:,~constInd);
% lb = lb(~constInd);
% ub = ub(~constInd);
% [sampleStruct.A, sampleStruct.b, sampleStruct.csense, sampleStruct.lb, sampleStruct.ub] = deal(A, b, csense, lb, ub);

if (~ isfield(sampleStruct, 'internal'))
    if any(~(csense == 'E' | csense == 'G' | csense == 'L'))
        display ('whoops.  csense can only contain E, G, or L')
        return;
    end
    Anew = A(csense == 'E', :);
    Bnew = b(csense == 'E');
    Cnew = sparse(sum(csense ~= 'E'), size(A,2));
    Cnew(csense(csense ~= 'E') == 'G', :) = -A(csense == 'G', :);
    Cnew(csense(csense ~= 'E') == 'L', :) = A(csense == 'L', :);
    Dnew = zeros(sum(csense ~= 'E'), 1);
    Dnew(csense(csense ~= 'E') == 'G') = -b(csense == 'G');
    Dnew(csense(csense ~= 'E') == 'L') = b(csense == 'L');

    % calculate offset
    if find(Bnew ~= 0)
        offset = Anew\Bnew;
    else
        offset = zeros(size(Anew,2), 1);
    end

    % rescale Bnew, Dnew
    Boffset = Bnew - Anew*offset;
    if (max(abs(Boffset)) > .0000000001)
        display('whoops.  It looks like the offset calculation made a mistake.  this should be zero.');
        max(abs(Boffset))
        return;
    end
    Doffset = Dnew - Cnew*offset;

    lbnew = lb - offset;
    ubnew = ub - offset;

    sampleStruct.internal.offset = offset;
    sampleStruct.internal.Anew = Anew;
    sampleStruct.internal.Cnew = Cnew;
    sampleStruct.internal.Dnew = Doffset;
    sampleStruct.internal.lbnew = lbnew;
    sampleStruct.internal.ubnew = ubnew;

    if (isfield(sampleStruct, 'warmupPts'))
        sampleStruct = rmfield(sampleStruct, 'warmupPts');
    end
    if ~isempty(bias)
        sampleStruct.internal.fixed = bias.index;
    else
        sampleStruct.internal.fixed = [];
    end
end

%% Generate warmup points
if (~ isfield(sampleStruct, 'warmupPts') )
    fprintf('Generating warmup points\n');
%     warmupPts = warmup(sampleStruct, nPoints, bias);
%MODIFICATION
    warmupPts = createHRWarmupTolerance(sampleStruct, nPoints, false, bias, nPointsCheck);
    if warmupPts == 0
        sampleStructOut = 0;
        mixedFrac = 0;
        return
    end
    sampleStruct.warmupPts = warmupPts;
    if (isfield(sampleStruct, 'points'))
        sampleStruct = rmfield(sampleStruct, 'points');
    end
    if (isfield(sampleStruct, 'bias'))
        sampleStruct = rmfield(sampleStruct, 'bias');
    end
    sampleStruct.steps = 0;
    save sampleStructTmp sampleStruct
else
    fprintf('Warmup points already present.\n');
%    save sampleStructTmp sampleStruct
end

%% Do actual sampling
fprintf('Sampling\n');
if(maxTime > 0 && maxSteps > 0)
    if threads < 0  %uses distributed toolbox.
        sampleStruct = ACHRSamplerDistributedGeneral(sampleStruct, ceil(maxSteps/50), 50, maxTime);
    else
        %FUNCTION LOCATED BELOW THIS DOCUMENT
        sampleStruct = ACHRSamplerParallelGeneralPercentile(sampleStruct, ceil(maxSteps/50), 50, maxTime, threads,[],previousSampling);
    end
    %mixedFrac = mixFraction(sampleStruct.points, sampleStruct.warmupPts, sampleStruct.internal.fixed);
    %Fernando SIlva: I am not sure how to adapt this mixedFraction to our
    %new way of sampling
     mixedFrac = 1;
else
    mixedFrac = 1;
end

sampleStructOut = sampleStruct;

return;
end

function [sampleStruct] = ACHRSamplerParallelGeneralPercentile(sampleStruct, nLoops, stepsPerPoint, maxtime, proc, fdirectory,previousSampling)

if ~exist('previousSampling','var') || isempty(previousSampling)
    previousSampling = [];
    disp('Normal Sampling')
else
    disp('Performing sampling using data from previous samplings: Distance between furthest and central solution ')
end

% Artificial Centering Hit-and-Run sampler with in place (memory) point management
%
% USAGE:
%
%    sampleStruct = ACHRSamplerParallelGeneral(sampleStruct, nLoops, stepsPerPoint, maxtime, proc, fdirectory)
%
% INPUTS:
%    sampleStruct:     Sampling structure
%    nLoops:           Number of iterations
%    stepsPerPoint:    Number of sampler steps per point saved
%    maxtime:          Amount of time to spend on calculation (in seconds)
%
% OPTIONAL INPUTS:
%    proc:             Number of processes if > 0.  Otherwise, the proces #.
%    fdirectory:       Do not use this parameter when calling function directly.
%
% OUTPUT:
%    sampleStruct:     Sampling structure with sample points
%
% .. Author: - Jan Schellenberger 1/29/07

warning off MATLAB:divideByZero;
% (vaguely) based on code by:
% Markus Herrgard, Gregory Hannum, Ines Thiele, Nathan Price 4/14/06

%proc == 0 means master
%proc greater than 1 means slave.
if nargin < 5 % not parallel at all.
    parallel = 0;
    proc = 0;
elseif nargin >= 5 && proc == 1 % not parallel (explicit)
    parallel = 0;
    proc = 0;
else % parallel.
    parallel = 1;
    if proc < 0 % an indication that this is a slave process
        proc = -proc;
    else % indicator that you are a master process
        numproc = proc;
        proc = 0;
        % clear all files that may exist
        delete('xxMasterfil*.mat');
        delete('xxRound*.mat');
        delete('xxRoundDonePrint*.mat');
        delete('xxRoundAck*.mat');
        delete('xxDoneRound*.mat');
        delete('xxDoneP*.mat');
        delete('xxGlobalDone*.mat*');
    end
end

% Minimum allowed distance to the closest constraint
maxMinTol = 1e-10;
% Ignore directions where u is really small
uTol = 1e-10;
safetycheck = false; % checks the direction of u for fixed directions.

totalStepCount = 0;
t0 = clock;


if proc == 0 % if master thread
    if( ~ isfield(sampleStruct, 'points'))
        points = sampleStruct.warmupPts; % start with warmup points
    else
        points = sampleStruct.points; % continue with points
    end
    offset = sampleStruct.internal.offset;

    [dimX,nPoints] = size(points);

    points = points - offset*ones(1, nPoints);

    ub = sampleStruct.internal.ubnew;
    lb = sampleStruct.internal.lbnew;
    A = sampleStruct.internal.Anew;
    C = sampleStruct.internal.Cnew;
    D = sampleStruct.internal.Dnew;
    fixed = union(sampleStruct.internal.fixed,find(ub==lb));
    if (~isfield(sampleStruct.internal,'N'))
        if size(A,1)==0
            N=[];
            sampleStruct.internal.N=N;
        else
            if issparse(A)
                N = null(full(A));
            else
                N = null(A);
            end
            sampleStruct.internal.N = N;
        end
    else
        N = sampleStruct.internal.N;
    end

    movable = (1:dimX)';
    movable(fixed) = [];
    if safetycheck
        Nsmall = null(full(A(:, movable)));
    else
        Nsmall = [];
    end

    % Find the center of the space
    centerPoint = mean(points, 2);

    fidErr = fopen('ACHRParallelError.txt','w');

    pointRange = 1:nPoints;
    totalloops = nLoops;

    if parallel
        blah = 1;
        display('saving master file.');
        save('xxMasterfile', 'ub', 'lb', 'A', 'C', 'D', 'fixed', 'N', 'movable', 'Nsmall', 'numproc', 'nPoints' );
        display('finished saving master file.  spawning processes');
        for i = 1:(numproc - 1) % goes from 1 to 7 if proc == 8
            command = strcat('matlab -singleCompThread -automation -nojvm -r ACHRSamplerParallelGeneral([],',num2str(nLoops),',',num2str(stepsPerPoint),',0,', num2str(-i) ,',''' ,pwd, ''');exit; &' );
            display(command)
            system(command);
        end
        display('finished spawning processes');
    end
end

if proc > 0 %slave threads only
    cd (fdirectory);
    load('xxMasterfile', 'ub', 'lb', 'A', 'C', 'D', 'fixed', 'N', 'movable', 'Nsmall', 'numproc', 'nPoints');
    blah = 1;
end
flag = 0;
for i = 1:nLoops
    if  ~isempty(previousSampling)
        %MODIFICATION: Recover relevant data from previous sampling,
        %explanation below
        minimumNumberOfSolutionsNeeded         = previousSampling.numberOfSolutions ;
        distanceFurthestCentral                = previousSampling.distanceFurthestCentral ;    
        nextTest                               = length(pointRange);
    end
    % actual sampling over pointRange
    for pointCount = pointRange
        % Create the random step size vector
        randVector = rand(stepsPerPoint,1);
        prevPoint  = points(:,pointCount);
        curPoint   = prevPoint;
        if mod(pointCount,200) == 0
            %display(pointCount);
        end
        saveCoords = prevPoint(fixed);
        for stepCount = 1:stepsPerPoint
            % Pick a random warmup point
            randPointID = ceil(nPoints*rand);
            randPoint = points(:,randPointID);

            % Get a direction from the center point to the warmup point
            u = (randPoint-centerPoint);
            if ~isempty(fixed) % no need to reproject if there are no fixed reactions.
                %ubefore = u;
                if safetycheck
                    u(movable) = Nsmall * (Nsmall' * u(movable));
                end
                %uafter = u;

                u(fixed) = 0; % takes care of biasing.
            end
            u = u/norm(u);

            % Figure out the distances to upper and lower bounds
            distUb = (ub - prevPoint);
            distLb = (prevPoint - lb);
            distD = (D-C*prevPoint);

            % Figure out positive and negative directions
            posDirn = (u > uTol);
            negDirn = (u < -uTol);
            move = C*u;
            posDirn2 = (move > uTol);
            negDirn2 = (move < -uTol);

            % Figure out all the possible maximum and minimum step sizes
            maxStepTemp = distUb./u;
            minStepTemp = -distLb./u;
            StepD = distD./move;
            maxStepVec = [maxStepTemp(posDirn);minStepTemp(negDirn);StepD(posDirn2 )];
            minStepVec = [minStepTemp(posDirn);maxStepTemp(negDirn);StepD(negDirn2 )];

            % Figure out the true max & min step sizes
            maxStep = min(maxStepVec);
            minStep = max(minStepVec);

            % Find new direction if we're getting too close to a constraint
            if (abs(minStep) < maxMinTol && abs(maxStep) < maxMinTol) || (minStep > maxStep)
                fprintf('Warning small step: %f %f\n',minStep,maxStep);
                continue;
            end

            % Pick a rand out of list_of_rands and use it to get a random
            % step distance
            stepDist = minStep + randVector(stepCount)*(maxStep-minStep);

            %fprintf('%d %d %d %f %f\n',i,pointCount,stepCount,minStep,maxStep);
            % Advance to the next point
            curPoint = prevPoint + stepDist*u;

            % Reproject the current point into the null space
            if mod (stepCount, 25) == 0
                if ~isempty(N)
                    curPoint = N* (N' * curPoint);
                end
                curPoint(fixed) = saveCoords;
            end

            % Print out amount of constraint violation
            if (mod(totalStepCount,1000)==0) && proc == 0 % only do for master thread
              fprintf(fidErr,'%10.8f\t%10.8f\t',max(curPoint-ub),max(lb-curPoint));
            end

            % Move points inside the space if reprojection causes problems
            overInd = (curPoint > ub);
            underInd = (curPoint < lb);
            if (sum(overInd)>0) || (sum(underInd)>0)
              curPoint(overInd) = ub(overInd);
              curPoint(underInd) = lb(underInd);
            end

            % Print out amount of constraint violation
            if (mod(totalStepCount,1000) == 0) && proc == 0 % only do for master thread
              fprintf(fidErr,'%10.8f\n',full(max(max(abs(A*curPoint)))));
            end

            prevPoint = curPoint;

            % Count the total number of steps
            totalStepCount = totalStepCount + 1;

        end % Steps per point

        % Final reprojection
        if ~isempty(N)
            curPoint = N* (N' * curPoint);
        end
        curPoint(fixed) = saveCoords;
        centerPoint = centerPoint + (curPoint - points(:,pointCount))/nPoints; % only swapping one point... it's trivial.

        % Swap current point in set of points.
        points(:,pointCount) = curPoint;   
        
        %MODIFICATION: This piece of code analyses the points being
        %sampled using data from a previous initial sampling. The previous
        %sampling must have  used the dynamic percentile as the data
        %related to the inflection point is being used here. 
        %Algorithm:
            %1. From the previous sampling, the following data is
            %recovered: 
                %   Euclidean distance between central and furthest solution
                %   Number of solutions returned by the dynamic percentile   
            %1. Once the sampling gets to the number of solutions needed (According to the dynamic percentile in the previous sampling),
                    %The euclidean distance is computed, the central
                    %solution is recovered. Also, using the euclidean distance between central and furthest solution (recovered from the previous sampling),
                    % those sampled points which have a minor or equal
                    % euclidean distance with the respecto to the central
                    % solution, are considered valid and saved.
                    %The number of valid solutions is compared to the
                    %number of solutions returned by the dynamic percentile
                    %and. If it is bigger or equal, then the sampling is
                    %stopped. If it is smaller, sampling goes on until
                    %there are enough new sampled points.
            %2. Compute The euclidean distance of the new sampled points
            %against the, previously recovered, central solution. Save the
            %valid solutions and continue until the number of valid
            %solutions is equal or bigger than the one given by the dynamic
            %percentile. 
       
        if ~isempty(previousSampling)
            if pointCount == minimumNumberOfSolutionsNeeded 
                pointsFinal                           = points(:,1:pointCount);
                 %FUNCTION LOCATED AT THE BOTTOM OF THIS DOCUMENT
                [centralSolution,currentDistancesMin] = loopEuclideanDistances(pointsFinal);
               numberOfValidSolutions                 = sum(currentDistancesMin <= (distanceFurthestCentral*(1+.1)));
               if numberOfValidSolutions >= minimumNumberOfSolutionsNeeded
                   pointsFinal = pointsFinal(:,currentDistancesMin <= (distanceFurthestCentral*(1+.1)));
                   flag        = 1;
                   points      = pointsFinal;
                   break
               else
                   validPoints = pointsFinal(:,currentDistancesMin <= (distanceFurthestCentral*(1+.1)));
               end
               %points = points(:,currentDistancesMax <= distanceFurthestCentral');
               nextTest = pointCount + (minimumNumberOfSolutionsNeeded - numberOfValidSolutions);
               previousTest = pointCount;
            end
            if pointCount == nextTest
                pointsFinal             = points(:,previousTest:pointCount);
                %FUNCTION LOCATED AT THE BOTTOM OF THIS DOCUMENT
                [currentDistancesMin]   = EuclideanDistancesOneSolution(pointsFinal,centralSolution);
                 tempVar                = pointsFinal(:,currentDistancesMin <= (distanceFurthestCentral*(1+.1)));
                 validPoints            = [validPoints,tempVar]; %#ok<AGROW> 
                 numberOfValidSolutions = size(validPoints,2);
               if numberOfValidSolutions >= minimumNumberOfSolutionsNeeded
                   pointsFinal = validPoints;
                   flag        = 1;
                   points      = pointsFinal;
                   break
               end
               nextTest = pointCount + (minimumNumberOfSolutionsNeeded - numberOfValidSolutions);
            end
        end
    end % Points per cycle

    t1 = clock();
    %fprintf('%10.0f s %d steps\n',etime(t1, t0),i*stepsPerPoint);
    if etime(t1, t0) > maxtime && proc == 0 % only master thread can terminate due to time limits.
        totalloops = i;
        break;
    end
    if flag == 1
        break
    end
end

if proc > 0 % slave threads terminate here.
    return;
end
points = points + offset*ones(1, size(points,2));
sampleStruct.points = points;
if ~ isfield(sampleStruct, 'steps')
    sampleStruct.steps = 0;
end

sampleStruct.steps = sampleStruct.steps + stepsPerPoint*totalloops;
% flag for all other handles to terminate.
if parallel
    save('xxGlobalDone', 'blah');
    delete('xxMaster*.mat');
end

fclose(fidErr);
end 

function out = subparts(nPoints, n, k)
    out = (floor(nPoints*k/n)+1) : (floor(nPoints*(k+1)/n));
return
end


function [centralSolution,distancesMin] = loopEuclideanDistances(points)
      numberofRelevantSolutions = size(points,2);
      TotalEuclideanDistance    = zeros(numberofRelevantSolutions,1,'single');
      nonZeroElements           = (sum(0:numberofRelevantSolutions-1));
      
     %Main Loop, euclidean distances are calculated. 
           columnIndexes = zeros(nonZeroElements,1);%,'single');
           rowIndexes    = zeros(nonZeroElements,1);%,'single');
        %calculedED can´t be single because sparse only admits double
           calculedED    = zeros(nonZeroElements,1);
           counter = 1;
           for column = 1:numberofRelevantSolutions
                currentSolution = points(:,column);
                %Creating a factor for jumping results already calculated
                    factor = 1 + column;
                    row =  factor;
                %While to calcule the euclidean distance of the current
                %solution against every other solution
                while row <= numberofRelevantSolutions 
                    
                    calculedED(counter,1) = norm(currentSolution - points(:,row));
                    columnIndexes(counter,1) = column;
                    rowIndexes(counter,1)    = row;
                    counter = counter + 1;
                    row     = row + 1;
        
                end
           end
           
           %Create SparseMatrix
           euclideanPerSolution = sparse(rowIndexes,columnIndexes,calculedED);
           
           %Making the sum for each solution. Sum column N, then Sum row N
           %to retrieve those values skipped in the loop (skipped to not make
           %the calculations twice)
           Index1 = 1;
           Index2 = 2;
           border = numberofRelevantSolutions;
           for i = 1: border
               columnIndex = 1:Index1;
               rowIndex = Index2:border;
               if i == 1
                   TotalEuclideanDistance(i) = full(sum(euclideanPerSolution(rowIndex,i)));
                   Index2 = Index2 + 1;
                   continue
               end
               
               if i == border
                   TotalEuclideanDistance(i) = full(sum(euclideanPerSolution(i,columnIndex)));
                   continue
               end
               TotalEuclideanDistance(i) = full(sum(euclideanPerSolution(rowIndex,i)))+ full(sum(euclideanPerSolution(i,columnIndex)));
               Index2 = Index2 + 1;
               Index1 = Index1 + 1;
           end
            
        %6. Normalizing the euclidean distance
            TotalSum                    = sum(TotalEuclideanDistance);
            NormalizedEuclideanDistance = TotalEuclideanDistance/TotalSum;

      %Recover the central solution and the euclidean solution and its
      %euclidean distance against every other solution.
            [~,minDistanceSolution] = min(NormalizedEuclideanDistance);
                columnsMin = full(euclideanPerSolution(:,minDistanceSolution));
                    columnsMin = columnsMin(columnsMin~=0);
                rowsMin = full(euclideanPerSolution(minDistanceSolution,:));
                    rowsMin = rowsMin(rowsMin~=0)';
                distancesMin = [rowsMin;0;columnsMin];
            centralSolution = points(:,minDistanceSolution);
            
end

function [distancesAgainstMinSolution] = EuclideanDistancesOneSolution(points,minSolution)
      distancesAgainstMinSolution = zeros(size(points,2),1);
      for i = 1:size(points,2)
          currentPoint                   = points(:,i);
          distancesAgainstMinSolution(i) = norm(minSolution-currentPoint);
      end          
            
end
